


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  mongoDB学习笔记 |    欧阳灿的博客</title>
  <meta name="description" content="不但要记录自己的努力，还要记录生活中的美好。">
  <!-- 标签页图标 -->
  
  <link rel="shortcut icon" href="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg95.699pic.com%2Felement%2F40097%2F3987.png_860.png&refer=http%3A%2F%2Fimg95.699pic.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659769333&t=2fa07943c842733641f4b355826cdfc5" type="image/x-icon">
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
    
      
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.css">

    
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          欧阳灿的博客
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              主页
            </li>
          </a>
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              博客
            </li>
          </a>
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="sort">
             分类
             <div class="categories-outer " id="sort-div">
               <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/Categories/%E9%9D%A2%E8%AF%95%E9%94%99%E9%A2%98/">面试错题</a></li></ul>
             </div>
          </li>
        
        
        <a href="/search">
          <li class="menu-li  animate__animated  animate__fadeInUp">
            <i class="ri-search-line"></i>
          </li>
        </a>
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        欧阳灿的博客
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>主页</span>
      </div>
    </a>
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>博客</span>
      </div>
    </a>
  
  
    <a href="/search">  
      <div class="mobile-menu-child  animate__animated  animate__fadeInUp">
        <i class="ri-search-line"></i>
      </div>
    </a>
    
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">mongoDB学习笔记</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Aug 11 2022</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h4 id="一、数据库相关"><a href="#一、数据库相关" class="headerlink" title="一、数据库相关"></a>一、数据库相关</h4><h5 id="1-连接"><a href="#1-连接" class="headerlink" title="1.连接"></a>1.连接</h5><p>（1）完整</p>
<pre><code>mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]
</code></pre>
<p>（2）使用默认端口</p>
<pre><code>mongodb://localhost
</code></pre>
<p>（3）使用shell</p>
<pre><code>mongo
</code></pre>
<h5 id="2-查询数据库"><a href="#2-查询数据库" class="headerlink" title="2.查询数据库"></a>2.查询数据库</h5><p>（1）查询所有数据库</p>
<pre><code>show dbs
</code></pre>
<h5 id="3-创建数据库"><a href="#3-创建数据库" class="headerlink" title="3.创建数据库"></a>3.创建数据库</h5><pre><code>use database_name
</code></pre>
<p>如果数据库不存在，则创建并切换到该数据库，存在则切换到该数据库。并且刚创建的数据库在没有插入数据的时候是不会显示的出来的，需要插入数据才能显示。</p>
<h5 id="4-删除数据库"><a href="#4-删除数据库" class="headerlink" title="4.删除数据库"></a>4.删除数据库</h5><p>先切换到指定数据库，然后执行以下命令</p>
<pre><code>#删除 test数据库
use test
db.dropDatabase()
</code></pre>
<h4 id="二、集合相关"><a href="#二、集合相关" class="headerlink" title="二、集合相关"></a>二、集合相关</h4><h5 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1.创建集合"></a>1.创建集合</h5><p>切换到指定数据库，然后执行如下命令</p>
<pre><code>db.createCollection(name, options)
</code></pre>
<p>说明：</p>
<p>name 要创建的集合名称，可选参数，指定有关内存大小及索引的选项</p>
<p>options参数：capped如果为true则创建固定集合（有着固定大小的集合）；size为固定集合指定一个最大值，如果capped为true需要指定该字段；max 指定固定集合中包含文档的最大数量，size代表文档的最大占用空间。并且插入文档会自动创建集合。</p>
<pre><code>#创建有参数的集合
db.creatCollection(&quot;test&quot;, &#123; capped : true, size : 1024, max : 1000&#125;)
#直接插入文档创建集合
db.test.insert(&#123;&quot;name&quot; : &quot;oyc&quot;&#125;)
</code></pre>
<h5 id="2-查看所有集合"><a href="#2-查看所有集合" class="headerlink" title="2.查看所有集合"></a>2.查看所有集合</h5><p>先切换到指定数据库，然后执行如下命令</p>
<pre><code>use test
show collections
</code></pre>
<h5 id="3-删除集合"><a href="#3-删除集合" class="headerlink" title="3.删除集合"></a>3.删除集合</h5><pre><code>db.COLLECTION_NAME.drop()
</code></pre>
<p>成功删除则返回true，否则返回false </p>
<h4 id="三、文档相关"><a href="#三、文档相关" class="headerlink" title="三、文档相关"></a>三、文档相关</h4><h5 id="1-插入文档"><a href="#1-插入文档" class="headerlink" title="1.插入文档"></a>1.插入文档</h5><p>使用insert()或insertOne()或insertMany()方法插入文档</p>
<pre><code>db.COLLECTION_NAME.insert(document)
</code></pre>
<pre><code>插入单条数据
db.collection.insertOne(
   &lt;document&gt;,
   &#123;
      writeConcern: &lt;document&gt;
   &#125;
)
插入多条数据 
db.collection.insertMany(
   [ &lt;document 1&gt; , &lt;document 2&gt;, ... ],
   &#123;
      writeConcern: &lt;document&gt;,
      ordered: &lt;boolean&gt;
   &#125;
)
document: 要写入的文档

writeConcern：写入策略，默认为1，即要求默认写操作，0是不要求

ordered：是否按照顺序写入，默认为true，按照顺序写入
</code></pre>
<h5 id="2-查询文档"><a href="#2-查询文档" class="headerlink" title="2.查询文档"></a>2.查询文档</h5><pre><code>db.COLLECTION_NAME.find(query, projection)
query ：可选，使用查询操作符指定查询条件
projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。
pretty()以格式化方法显示文档
</code></pre>
<h5 id="3-更新文档"><a href="#3-更新文档" class="headerlink" title="3.更新文档"></a>3.更新文档</h5><p>使用update()和save()方法来更新集合中的文档</p>
<p>（1）update()方法</p>
<pre><code>db.collection.update(
   &lt;query&gt;,
   &lt;update&gt;,
   &#123;
     upsert: &lt;boolean&gt;,
     multi: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   &#125;
)
db.collection.updata(&#123;&quot;name&quot;:&quot;oyc&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:21&#125;&#125;)
参数说明：
query : update的查询条件，类似sql update查询内where后面的。
update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的
upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。
multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。
writeConcern :可选，抛出异常的级别。
</code></pre>
<p>（2）save()方法</p>
<p>save() 方法通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入。</p>
<pre><code>db.collection.save(
   &lt;document&gt;,
   &#123;
     writeConcern: &lt;document&gt;
   &#125;
)
#将_id主键为ObjectId(&quot;123&quot;)的文档进行保存，如果存在就更新，如果不存在就创建
db.collection.save(&#123;&quot;_id&quot;:ObjectId(&quot;123&quot;),&quot;name&quot;:&quot;oyc123&quot;&#125;)
参数说明：
document : 文档数据。
writeConcern :可选，抛出异常的级别。
</code></pre>
<h5 id="4-删除文档"><a href="#4-删除文档" class="headerlink" title="4.删除文档"></a>4.删除文档</h5><pre><code>db.collection.remove(
   &lt;query&gt;,
   &lt;justOne&gt;
)
参数说明：
db.collection.remove(&#123;&quot;name&quot;:&quot;oyc&quot;&#125;)
query :（可选）删除的文档的条件。
justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。
</code></pre>
<h4 id="四、条件操作符"><a href="#四、条件操作符" class="headerlink" title="四、条件操作符"></a>四、条件操作符</h4><pre><code>1.大于（&gt;）: $gt
db.collection2.find(&#123;age : &#123;$gt : 30&#125;&#125;)
2.大于等于（&gt;=）： $gte
db.collection2.find(&#123;age : &#123;$gte : 30&#125;&#125;)
3.小于（&lt;）：$lt
db.collection2.find(&#123;age : &#123;$lt : 20&#125;&#125;)
4.小于等于（&lt;=）：$lte
db.collection2.find(&#123;age : &#123;$lte : 20&#125;&#125;)
5.$lt 和 $gt
db.collection2.find(&#123;age : &#123;$gt : 30, $lt : 60,&#125;&#125;)
</code></pre>
<h4 id="五、-type操作符"><a href="#五、-type操作符" class="headerlink" title="五、$type操作符"></a>五、$type操作符</h4><p>MongoDB 中可以使用的类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">数字</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Double</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">3</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Array</td>
<td align="center">4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Binary data</td>
<td align="center">5</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">6</td>
<td align="center">已废弃</td>
</tr>
<tr>
<td align="center">ObjectId</td>
<td align="center">7</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="center">8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">9</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">10</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">RegularExpression</td>
<td align="center">11</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">JavaScript</td>
<td align="center">13</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="center">14</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">JavaScript(with scope)</td>
<td align="center">15</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">32 bit integer</td>
<td align="center">16</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Timestamp</td>
<td align="center">17</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">64 bit integer</td>
<td align="center">18</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Min key</td>
<td align="center">255</td>
<td align="center">Query with -1</td>
</tr>
<tr>
<td align="center">Max key</td>
<td align="center">127</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>db.collection2.find(&#123;&quot;name&quot; : &#123;$type :2&#125;&#125;)
db.collection2.find(&#123;&quot;name&quot; : &#123;$type :&#39;string&#39;&#125;&#125;)
</code></pre>
<h4 id="六、MongoDB-Limit与Skip方法"><a href="#六、MongoDB-Limit与Skip方法" class="headerlink" title="六、MongoDB Limit与Skip方法"></a>六、MongoDB Limit与Skip方法</h4><h5 id="1-limit-读取记录的条数"><a href="#1-limit-读取记录的条数" class="headerlink" title="1.limit()读取记录的条数"></a>1.limit()读取记录的条数</h5><pre><code>#限制查询出来的文档中只显示一个文档
db.COLLECTION_NAME.find().limit(NUMBER)
</code></pre>
<h5 id="2-skip-跳过的记录条数"><a href="#2-skip-跳过的记录条数" class="headerlink" title="2.skip()跳过的记录条数"></a>2.skip()跳过的记录条数</h5><pre><code>#在查询出来的文档中，跳过number1个文档后显示number2个文档。
db.COLLECTION_NAME.find().limit(NUMBER2).skip(NUMBER1)
</code></pre>
<h4 id="七、排序"><a href="#七、排序" class="headerlink" title="七、排序"></a>七、排序</h4><p>sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<h5 id="1-升序排序"><a href="#1-升序排序" class="headerlink" title="1.升序排序"></a>1.升序排序</h5><pre><code>db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) 
</code></pre>
<h5 id="2-降序排序"><a href="#2-降序排序" class="headerlink" title="2.降序排序"></a>2.降序排序</h5><pre><code>db.COLLECTION_NAME.find().sort(&#123;KEY:-1&#125;)
</code></pre>
<h4 id="八、索引"><a href="#八、索引" class="headerlink" title="八、索引"></a>八、索引</h4><p>使用createIndex()方法创建索引</p>
<pre><code>db.collection.createIndex(keys, options)
</code></pre>
<p>语法中 key值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p>
<p>createIndex() 接收可选参数，可选参数列表如下：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://raw.githubusercontent.com/MagicTmac1/Picture_repo/master/202208101450358.png" >
        </sapn>
      </p>
<h4 id="九、聚合"><a href="#九、聚合" class="headerlink" title="九、聚合"></a>九、聚合</h4><h5 id="1-聚合"><a href="#1-聚合" class="headerlink" title="1.聚合"></a>1.聚合</h5><p>聚合主要用来处理数据（平均值、求和等），并返回计算结果。</p>
<pre><code>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)
</code></pre>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://raw.githubusercontent.com/MagicTmac1/Picture_repo/master/202208101452917.png" >
        </sapn>
      </p>
<h5 id="2-聚合管道"><a href="#2-聚合管道" class="headerlink" title="2.聚合管道"></a>2.聚合管道</h5><p>聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。</p>
<p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p>
<p>聚合框架中常用的几个操作：</p>
<ul>
<li><p>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</p>
</li>
<li><p>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p>
</li>
<li><p>$limit：用来限制MongoDB聚合管道返回的文档数。</p>
</li>
<li><p>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</p>
</li>
<li><p>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p>
</li>
<li><p>$group：将集合中的文档分组，可用于统计结果。</p>
</li>
<li><p>$sort：将输入文档排序后输出。</p>
</li>
<li><p>$geoNear：输出接近某一地理位置的有序文档。</p>
</li>
</ul>
<p>统计colection2集合中记录条数</p>
<pre><code>db.collection2.aggregate( [
   &#123;
     $group: &#123;
        _id: null,
        count: &#123; $sum: 1 &#125;
     &#125;
   &#125;
] )
</code></pre>
<p>统计collection2集合age的和</p>
<pre><code>db.collection2.aggregate( [
   &#123;
     $group: &#123;
        _id: null,
        total: &#123; $sum: &quot;$age&quot; &#125;
     &#125;
   &#125;
] )
</code></pre>
<p>统计collection2集合中age&gt;&#x3D;10且&#x3D;30的age的和</p>
<pre><code>db.collection2.aggregate( [
  &#123; $match : &#123; age : &#123; $gte : 10, $lte : 30 &#125; &#125; &#125;,
  &#123;
     $group: &#123;
        _id: null,
        total: &#123; $sum: &quot;$age&quot; &#125;
     &#125;
  &#125;
] )
</code></pre>
<h4 id="十、复制"><a href="#十、复制" class="headerlink" title="十、复制"></a>十、复制</h4><h5 id="1-复制："><a href="#1-复制：" class="headerlink" title="1.复制："></a>1.复制：</h5><p>复制是将数据同步在多个服务器的过程</p>
<h5 id="2-复制原理"><a href="#2-复制原理" class="headerlink" title="2.复制原理"></a>2.复制原理</h5><p><strong>MongoDB复制至少需要2个节点，其中1个是主节点</strong>，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。常见的搭配的方式：一主一从、一主多从。</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://raw.githubusercontent.com/MagicTmac1/Picture_repo/master/202208101503640.png" >
        </sapn>
      </p>
<p>以上结构图中，客户端从主节点读取数据，在客户端写入数据到主节点时，主节点与从节点交互保证数据一致性。</p>
<h4 id="十一、分片"><a href="#十一、分片" class="headerlink" title="十一、分片"></a>十一、分片</h4><h5 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h5><p>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我么就可以在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>
<h5 id="2-为什么使用分片"><a href="#2-为什么使用分片" class="headerlink" title="2.为什么使用分片"></a>2.为什么使用分片</h5><ul>
<li><p>复制所有的写入操作到主节点</p>
</li>
<li><p>延迟的敏感数据会在主节点上查询</p>
</li>
<li><p>单个副本集限制在12个节点</p>
</li>
<li><p>当请求量巨大时出现内存不足</p>
</li>
<li><p>本地磁盘不足</p>
</li>
<li><p>垂直扩展价格昂贵</p>
</li>
</ul>
<h5 id="3-MongoDB分片"><a href="#3-MongoDB分片" class="headerlink" title="3.MongoDB分片"></a>3.MongoDB分片</h5><p>分片集群结构</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://raw.githubusercontent.com/MagicTmac1/Picture_repo/master/202208101506410.png" >
        </sapn>
      </p>
<ul>
<li><p>Shard：用于存储实际的数据块，实际生产环境中一个Shard Server角色可由几台机器组成一个replica set承担，防止单点故障</p>
</li>
<li><p>Config Server：mongod实例，存储整个ClusterMetadata，其中包括chunk信息</p>
</li>
<li><p>Query Routers:：前端路由，客户端由此接入，且整个集群看上去像单一数据库，前端应用可以透明使用。</p>
</li>
</ul>
<h4 id="十二、备份与还原"><a href="#十二、备份与还原" class="headerlink" title="十二、备份与还原"></a>十二、备份与还原</h4><pre><code>mongodump -h dbhost -d dbname -o dbdirectory
-h：
MongoDB 所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017
-d：
需要备份的数据库实例，例如：test
-o：
备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。
</code></pre>
<p>mongodump 命令可选参数列表如下所示：</p>
<p>
        <span class="lazyload-img-span">
        <img   
           data-src="https://raw.githubusercontent.com/MagicTmac1/Picture_repo/master/202208101510128.png" >
        </sapn>
      </p>
<pre><code>mongodump
</code></pre>
<p> 执行以上命令后，客户端会连接到ip为 127.0.0.1 端口号为 27017 的MongoDB服务上，并备份所有数据到 bin&#x2F;dump&#x2F; 目录中。</p>
<h4 id="十三、监控"><a href="#十三、监控" class="headerlink" title="十三、监控"></a>十三、监控</h4><p>了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。MongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。</p>
<h5 id="1-mongostat-命令"><a href="#1-mongostat-命令" class="headerlink" title="1.mongostat 命令"></a>1.mongostat 命令</h5><p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。</p>
<p>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令。配置过环境路径的就直接命令行输入mongostat。</p>
<h5 id="2-mongotop-命令"><a href="#2-mongotop-命令" class="headerlink" title="2.mongotop 命令"></a>2.mongotop 命令</h5><p>mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。</p>
<p>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，配置过环境路径的就直接命令行输入mongotop。</p>
<h4 id="十四、MongoDB高级"><a href="#十四、MongoDB高级" class="headerlink" title="十四、MongoDB高级"></a>十四、MongoDB高级</h4><h5 id="1-关系"><a href="#1-关系" class="headerlink" title="1.关系"></a>1.关系</h5><p>MongoDB 中的关系可以是：</p>
<ul>
<li>1:1 (1对1)</li>
<li>1: N (1对多)</li>
<li>N: 1 (多对1)</li>
<li>N: N (多对多)</li>
</ul>
<p>下面以用户的地址为例</p>
<p>（1）嵌入式关系</p>
<p>缺点：如果用户和用户地址在不断增加，数据量不断变大，会影响读写性能</p>
<pre><code>&#123;
   &quot;_id&quot;:ObjectId(&quot;52ffc33cd85242f436000001&quot;),
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;,
   &quot;name&quot;: &quot;Tom Benzamin&quot;,
   &quot;address&quot;: [
      &#123;
         &quot;building&quot;: &quot;22 A, Indiana Apt&quot;,
         &quot;pincode&quot;: 123456,
         &quot;city&quot;: &quot;Los Angeles&quot;,
         &quot;state&quot;: &quot;California&quot;
      &#125;,
      &#123;
         &quot;building&quot;: &quot;170 A, Acropolis Apt&quot;,
         &quot;pincode&quot;: 456789,
         &quot;city&quot;: &quot;Chicago&quot;,
         &quot;state&quot;: &quot;Illinois&quot;
      &#125;]
&#125; 
</code></pre>
<p>查询</p>
<pre><code>db.users.findOne(&#123;&quot;name&quot;:&quot;Tom Benzamin&quot;&#125;,&#123;&quot;address&quot;:1&#125;)
</code></pre>
<p>（2）引用关系</p>
<pre><code>&#123;
   &quot;_id&quot;:ObjectId(&quot;52ffc33cd85242f436000001&quot;),
   &quot;contact&quot;: &quot;987654321&quot;,
   &quot;dob&quot;: &quot;01-01-1991&quot;,
   &quot;name&quot;: &quot;Tom Benzamin&quot;,
   &quot;address_ids&quot;: [
      ObjectId(&quot;52ffc4a5d85242602e000000&quot;),
      ObjectId(&quot;52ffc4a5d85242602e000001&quot;)
   ]
&#125;
</code></pre>
<p>这种方法需要两次查询，第一次查询用户地址的对象id（ObjectId），第二次通过查询的id获取用户的详细地址信息</p>
<pre><code>var result = db.users.findOne(&#123;&quot;name&quot;:&quot;Tom Benzamin&quot;&#125;,&#123;&quot;address_ids&quot;:1&#125;)
var addresses = db.address.find(&#123;&quot;_id&quot;:&#123;&quot;$in&quot;:result[&quot;address_ids&quot;]&#125;&#125;)
</code></pre>
<h5 id="2-查询分析"><a href="#2-查询分析" class="headerlink" title="2.查询分析"></a>2.查询分析</h5><p>查询分析常用函数explain()和hint()</p>
<p>（1）explain 操作提供了查询信息，使用索引及查询统计等。有利于我们对索引的优化。</p>
<p>创建gender和user_name的索引</p>
<pre><code>db.users.ensureIndex(&#123;gender:1,user_name:1&#125;)
</code></pre>
<p>使用explaing </p>
<pre><code>db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).explain()
</code></pre>
<p>返回结果如下：</p>
<pre><code>&#123;
   &quot;cursor&quot; : &quot;BtreeCursor gender_1_user_name_1&quot;,
   &quot;isMultiKey&quot; : false,
   &quot;n&quot; : 1,
   &quot;nscannedObjects&quot; : 0,
   &quot;nscanned&quot; : 1,
   &quot;nscannedObjectsAllPlans&quot; : 0,
   &quot;nscannedAllPlans&quot; : 1,
   &quot;scanAndOrder&quot; : false,
   &quot;indexOnly&quot; : true,
   &quot;nYields&quot; : 0,
   &quot;nChunkSkips&quot; : 0,
   &quot;millis&quot; : 0,
   &quot;indexBounds&quot; : &#123;
      &quot;gender&quot; : [
         [
            &quot;M&quot;,
            &quot;M&quot;
         ]
      ],
      &quot;user_name&quot; : [
         [
            &#123;
               &quot;$minElement&quot; : 1
            &#125;,
            &#123;
               &quot;$maxElement&quot; : 1
            &#125;
         ]
      ]
   &#125;
&#125;
</code></pre>
<ul>
<li><p>indexOnly: 字段为 true ，表示我们使用了索引。</p>
</li>
<li><p>cursor：因为这个查询使用了索引，MongoDB 中索引存储在B树结构中，所以这是也使用了 BtreeCursor 类型的游标。如果没有使用索引，游标的类型是 BasicCursor。这个键还会给出你所使用的索引的名称，你通过这个名称可以查看当前数据库下的system.indexes集合（系统自动创建，由于存储索引信息，这个稍微会提到）来得到索引的详细信息。</p>
</li>
<li><p>n：当前查询返回的文档数量。</p>
</li>
<li><p>nscanned&#x2F;nscannedObjects：表明当前这次查询一共扫描了集合中多少个文档，我们的目的是，让这个数值和返回文档的数量越接近越好。</p>
</li>
<li><p>millis：当前查询所需时间，毫秒数。</p>
</li>
<li><p>indexBounds：当前查询具体使用的索引。</p>
</li>
</ul>
<p>（2）使用 hint()</p>
<p>可以使用 hint 来强制 MongoDB 使用一个指定的索引。<strong>这种方法某些情形下会提升性能</strong>。 一个有索引的 collection 并且执行一个多字段的查询(一些字段已经索引了)。</p>
<p>如下查询实例指定了使用 <code>gender</code> 和<code> user_name</code> 索引字段来查询：</p>
<pre><code>db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).hint(&#123;gender:1,user_name:1&#125;)
</code></pre>
<p>可以使用 explain() 函数来分析以上查询：</p>
<pre><code>db.users.find(&#123;gender:&quot;M&quot;&#125;,&#123;user_name:1,_id:0&#125;).hint(&#123;gender:1,user_name:1&#125;).explain()
</code></pre>
<h5 id="3-原子操作"><a href="#3-原子操作" class="headerlink" title="3.原子操作"></a>3.原子操作</h5><p>mongodb不支持事务，但是提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。原子操作命令如下：</p>
<p>（1）$set 用来指定一个键并更新键值，若键不存在并创建。</p>
<pre><code>&#123; $set : &#123; field : value &#125; &#125;
</code></pre>
<p>（2）$unset 用来删除一个键。</p>
<pre><code>&#123; $unset : &#123; field : 1&#125; &#125;
</code></pre>
<p>（3）$inc 可以对文档的某个值为数字型（只能为满足要求的数字）的键进行增减的操作。</p>
<pre><code>&#123; $inc : &#123; field : value &#125; &#125;
</code></pre>
<p>（4）$push 把value追加到field里面去，field一定要是数组类型才行，如果field不存在，会新增一个数组类型加进去。</p>
<pre><code>&#123; $push : &#123; field : value &#125; &#125;
</code></pre>
<p>（5）$pushAll 同$push,只是一次可以追加多个值到一个数组字段内。</p>
<pre><code>&#123; $pushAll : &#123; field : value_array &#125; &#125;
</code></pre>
<p>（6）$pull 从数组field内删除一个等于value值。</p>
<pre><code>&#123; $pull : &#123; field : _value &#125; &#125;
</code></pre>
<p>（7）$addToSet 增加一个值到数组内，而且只有当这个值不在数组内才增加。</p>
<p>（8）$pop 删除数组的第一个或最后一个元素</p>
<pre><code>&#123; $pop : &#123; field : 1 &#125; &#125;
</code></pre>
<p>（9）$rename 修改字段名称</p>
<pre><code>&#123; $rename : &#123; old_field_name : new_field_name &#125; &#125;
</code></pre>
<p>（10）$bit 位操作，integer类型</p>
<pre><code>&#123;$bit : &#123; field : &#123;and : 5&#125;&#125;&#125;
</code></pre>
<h5 id="4-高级索引"><a href="#4-高级索引" class="headerlink" title="4.高级索引"></a>4.高级索引</h5><pre><code>&#123;
   &quot;address&quot;: &#123;
      &quot;city&quot;: &quot;Los Angeles&quot;,
      &quot;state&quot;: &quot;California&quot;,
      &quot;pincode&quot;: &quot;123&quot;
   &#125;,
   &quot;tags&quot;: [
      &quot;music&quot;,
      &quot;cricket&quot;,
      &quot;blogs&quot;
   ],
   &quot;name&quot;: &quot;Tom Benzamin&quot;
&#125;
</code></pre>
<p>（1）索引数组</p>
<p>假设我们基于标签来检索用户，为此我们需要对集合中的数组 tags 建立索引。在数组中创建索引，需要对数组中的每个字段依次建立索引。所以在我们为数组 tags 创建索引时，会为 music、cricket、blogs三个值建立单独的索引</p>
<p>创建数组索引</p>
<pre><code>db.users.ensureIndex(&#123;&quot;tags&quot;:1&#125;)
</code></pre>
<p> 检索集合的 tags 字段</p>
<pre><code>db.users.find(&#123;tags:&quot;cricket&quot;&#125;)
</code></pre>
<p>（2）索引子文档字段</p>
<p>假设我们需要通过city、state、pincode字段来检索文档，由于这些字段是子文档的字段，所以我们需要对子文档建立索引。</p>
<p>创建索引</p>
<pre><code>db.users.ensureIndex(&#123;&quot;address.city&quot;:1,&quot;address.state&quot;:1,&quot;address.pincode&quot;:1&#125;)
</code></pre>
<p>检索数据</p>
<pre><code>db.users.find(&#123;&quot;address.city&quot;:&quot;Los Angeles&quot;,&quot;address.state&quot;:&quot;California&quot;,&quot;address.pincode&quot;:&quot;123&quot;&#125;)
</code></pre>
<p>（3）索引最大范围</p>
<p>集合中索引不能超过64个<br>索引名的长度不能超过128个字符<br>一个复合索引最多可以有31个字段</p>
<h5 id="5-ObjectId"><a href="#5-ObjectId" class="headerlink" title="5.ObjectId"></a>5.ObjectId</h5><p>ObjectId 是一个12字节 BSON 类型数据，有以下格式：</p>
<ul>
<li><p>前4个字节表示时间戳</p>
</li>
<li><p>接下来的3个字节是机器标识码</p>
</li>
<li><p>紧接的两个字节由进程id组成（PID）</p>
</li>
<li><p>最后三个字节是随机数。</p>
</li>
</ul>
<p>MongoDB中存储的文档必须有一个”_id”键。这个键的值可以是任何类型的，默认是个ObjectId对象。在一个集合里面，每个文档都有唯一的”_id”值，来确保集合里面每个文档都能被唯一标识。MongoDB采用ObjectId，而不是其他比较常规的做法（比如自动增加的主键）的主要原因，因为在多个 服务器上同步自动增加主键值既费力还费时。</p>
<p>（1）创建新的ObjectId</p>
<pre><code>newObjectId = ObjectId()
</code></pre>
<p>（2）创建文档的时间戳</p>
<pre><code>ObjectId(&quot;5349b4ddd2781d08c09890f4&quot;).getTimestamp()
</code></pre>
<p>（3）ObjectId 转换为字符串</p>
<pre><code>new ObjectId().str
</code></pre>
<h5 id="6-mapReduce"><a href="#6-mapReduce" class="headerlink" title="6.mapReduce"></a>6.mapReduce</h5><p>Map-Reduce是一种计算模型，简单地说就是将大量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（Reduce）。</p>
<p>基本语法：</p>
<pre><code>db.collection.mapReduce(
   function() &#123;emit(key,value);&#125;,  //map 函数
   function(key,values) &#123;return reduceFunction&#125;,   //reduce 函数
   &#123;
      out: collection,
      query: document,
      sort: document,
      limit: number
   &#125;
)
</code></pre>
<p>使用 MapReduce 要实现两个函数 Map 函数和 Reduce 函数,Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。</p>
<p>Map 函数必须调用 emit(key, value) 返回键值对。</p>
<p>参数说明:</p>
<ul>
<li>map ：映射函数 (生成键值对序列,作为 reduce 函数参数)。</li>
<li>reduce 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。。</li>
<li>out 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。</li>
<li>query 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）</li>
<li>sort 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制</li>
<li>limit 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）</li>
</ul>
<p>返回结果参数说明：</p>
<ul>
<li>result：储存结果的collection的名字,这是个临时集合，MapReduce的连接关闭后自动就被删除了。</li>
<li>timeMillis：执行花费的时间，毫秒为单位</li>
<li>input：满足条件被发送到map函数的文档个数</li>
<li>emit：在map函数中emit被调用的次数，也就是所有集合中的数据总量</li>
<li>ouput：结果集合中的文档个数（count对调试非常有帮助）</li>
<li>ok：是否成功，成功为1</li>
<li>err：如果失败，这里可以有失败原因，不过从经验上来看，原因比较模糊，作用不大</li>
</ul>
<h5 id="7-全文索引"><a href="#7-全文索引" class="headerlink" title="7.全文索引"></a>7.全文索引</h5><p>全文检索对每一个词建立一个索引，指明该词在文章中出现的位置和次数，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。类似于通过字典中检索字表查字的过程</p>
<p>（1）创建全文索引</p>
<pre><code>db.posts.ensureIndex(&#123;post_text:&quot;text&quot;&#125;)
</code></pre>
<p>（2）使用全文索引</p>
<pre><code>db.posts.find(&#123;$text:&#123;$search:&quot;mongodb&quot;&#125;&#125;)
</code></pre>
<p>（3）删除索引</p>
<pre><code>db.posts.dropIndex(&quot;post_text_text&quot;)
</code></pre>
<h5 id="8-正则表达式"><a href="#8-正则表达式" class="headerlink" title="8.正则表达式"></a>8.正则表达式</h5><p>使用 $regex 操作符来设置匹配字符串的正则表达式。</p>
<p>（1）使用正则表达式</p>
<pre><code>db.posts.find(&#123;post_text:&#123;$regex:&quot;runoob&quot;&#125;&#125;)
</code></pre>
<p>（2）不区分大小写</p>
<p>如果检索需要不区分大小写，我们可以设置 $options 为 $i。</p>
<h5 id="9-GridFS"><a href="#9-GridFS" class="headerlink" title="9.GridFS"></a>9.GridFS</h5><p>GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。</p>
<p>GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。</p>
<p>GridFS 可以更好的存储大于16M的文件。</p>
<p>GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k&#x2F;个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。</p>
<p>GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。</p>
<p>每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。</p>
<p>以下是简单的 fs.files 集合文档：</p>
<pre><code>&#123;
   &quot;filename&quot;: &quot;test.txt&quot;,
   &quot;chunkSize&quot;: NumberInt(261120),
   &quot;uploadDate&quot;: ISODate(&quot;2014-04-13T11:32:33.557Z&quot;),
   &quot;md5&quot;: &quot;7b762939321e146569b07f72c62cca4f&quot;,
   &quot;length&quot;: NumberInt(646)
&#125;
</code></pre>
<p>以下是简单的 fs.chunks 集合文档：</p>
<pre><code>&#123;
   &quot;files_id&quot;: ObjectId(&quot;534a75d19f54bfec8a2fe44b&quot;),
   &quot;n&quot;: NumberInt(0),
   &quot;data&quot;: &quot;Mongo Binary Data&quot;
&#125;
</code></pre>
<p>GridFS 添加文件<br>现在我们使用 GridFS 的 put 命令来存储 mp3 文件。 调用 MongoDB 安装目录下bin的 mongofiles.exe工具。</p>
<p>打开命令提示符，进入到MongoDB的安装目录的bin目录中，找到mongofiles.exe，并输入下面的代码：</p>
<pre><code>mongofiles.exe -d gridfs put song.mp3
</code></pre>
<p>-d gridfs 指定存储文件的数据库名称，如果不存在该数据库，MongoDB会自动创建。如果不存在该数据库，MongoDB会自动创建。Song.mp3 是音频文件名。</p>
<p>使用以下命令来查看数据库中文件的文档：</p>
<pre><code>db.fs.files.find()
</code></pre>
<p>以上命令执行后返回以下文档数据：</p>
<pre><code>&#123;
   _id: ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;), 
   filename: &quot;song.mp3&quot;, 
   chunkSize: 261120, 
   uploadDate: new Date(1397391643474), md5: &quot;e4f53379c909f7bed2e9d631e15c1c41&quot;,
   length: 10401959 
&#125;
</code></pre>
<p>我们可以看到 fs.chunks 集合中所有的区块，以下我们得到了文件的 _id 值，我们可以根据这个 _id 获取区块(chunk)的数据：</p>
<pre><code>db.fs.chunks.find(&#123;files_id:ObjectId(&#39;534a811bf8b4aa4d33fdf94d&#39;)&#125;)
</code></pre>
<h5 id="10-自动增长"><a href="#10-自动增长" class="headerlink" title="10.自动增长"></a>10.自动增长</h5><p>sequence_value 字段是序列通过自动增长后的一个值。</p>
<pre><code>db.counters.insert(&#123;_id:&quot;productid&quot;,sequence_value:0&#125;)
</code></pre>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
          <div class="space-toc-main animate__animated  animate__fadeInUp">
            
           </div>
        
      </div>
   </div>
    <!-- 评论 -->
    
    <div class="bottom-comments-outer">
      <div class="bottom-comments-inner">
        <!-- valine -->
        
        <!-- Gitalk -->
        
          <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk-container" style="margin-top: 100px;"></div>
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '5f07bbb19c182716513e',
        clientSecret: '4cad15f3f8d8c9fb8b1056b37a1f08815f25efbb',
        id: window.location.pathname,
        repo: 'MagicTmac1.github.io',
        owner: 'MagicTmac1',
        admin: 'MagicTmac1'
    })
    gitalk.render('gitalk-container')
</script>
        
        <!-- livere -->
        
        </div>
      </div>
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>世界上只有一种英雄主义，那就是了解生命而且热爱生命的人。-——罗曼罗兰</p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/MagicTmac1" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:ouyangcan0127@163.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



    
      
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.1/build/highlight.min.js"></script>

      <script>hljs.initHighlightingOnLoad();</script>
    

</body>
</html>
